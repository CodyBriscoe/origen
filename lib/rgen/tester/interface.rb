require 'active_support/concern'

module RGen
  module Tester
    # Include this module in any class you define as a test interface
    module Interface
      extend ActiveSupport::Concern

      included do
        RGen.add_interface(self)
      end

      # This identifier will be used to make labels and other references unique to the
      # current application. This will help to avoid name duplication if a program is
      # comprised of many modules generated by RGen.
      #
      # Override in the application interface to customize, by default the identifier
      # will be RGen.config.initials
      def app_identifier
        RGen.config.initials || 'Anon App'
      end

      def close(options = {})
        sheet_generators.each do |generator|
          generator.close(options)
        end
      end

      # Compile a template file
      def compile(file, options = {})
        RGen.file_handler.preserve_state do
          begin
            file = RGen.file_handler.clean_path_to_template(file)
            RGen.generator.compile_file_or_directory(file, initial_options: options)
          rescue
            file = RGen.file_handler.clean_path_to(file)
            RGen.generator.compile_file_or_directory(file, initial_options: options)
          end
        end
      end

      def import(file, options = {})
        # Attach the import request to the first generator, when it imports
        # it any generated resources will automatically find their way to the
        # correct generator/collection
        generator = flow || sheet_generators.first
        generator.import(file, options)
      end

      def render(file, options = {})
        if sheet_generators.size > 1
          fail "You must specify which generator to render content to! e.g.  i.test_instances.render '#{file}'"
        else
          sheet_generators.first.render(file, options)
        end
      end

      def write_files(options = {})
        sheet_generators.each do |generator|
          generator.finalize(options)
        end
        sheet_generators.each do |generator|
          generator.write_to_file(options) if generator.to_be_written?
        end
        reset_globals
      end

      # All generators should push to this array whenever they reference a pattern
      # so that it is captured in the pattern list, e.g.
      #   RGen.interface.referenced_patterns << pattern
      def referenced_patterns
        @@referenced_patterns ||= []
      end

      # Add a comment line into the buffer
      def comment(text)
        comments << text
      end

      def comments
        @@comments ||= []
      end

      def discard_comments
        @@comments = nil
      end

      # Returns the buffered description comments and clears the buffer
      def consume_comments
        c = comments
        discard_comments
        c
      end

      def top_level_flow
        @@top_level_flow ||= nil
      end
      alias_method :top_level_flow_filename, :top_level_flow

      def flow_generator
        flow
      end

      def set_top_level_flow
        @@top_level_flow = flow_generator.output_file
      end

      def clear_top_level_flow
        @@top_level_flow = nil
      end

      # A storage Hash that all generators can push comment descriptions
      # into when generating.
      # At the end of a generation run this will contain all descriptions
      # for all flows that were just created.
      #
      # Access via RGen.interface.descriptions
      def descriptions
        @@descriptions ||= Parser::DescriptionLookup.new
      end

      # Any tests generated within the given block will be generated in resources mode.
      # Generally this means that all resources for a given test will be generated but
      # flow entries will be inhibited.
      def resources_mode
        orig = @resources_mode
        @resources_mode = true
        yield
        @resources_mode = orig
      end

      def resources_mode?
        @resources_mode
      end

      def identity_map # :nodoc:
        @@identity_map ||= RGen::Tester::Generator::IdentityMap.new
      end

      module ClassMethods
        # Returns true if the interface class supports the
        # given tester instance
        def supports?(tester_instance)
          # Testers uses different platform check than RGen core
          if self.respond_to?('platform')
            tester_instance.is_a?(platform)
          else
            tester_instance.is_a?(self::PLATFORM)
          end
        end
      end
    end
  end
end
